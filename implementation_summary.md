# 🧠 Implementation Summary – Dog Breeds API

## 👋 Introduction

This project is a RESTful API built using **FastAPI** that connects to [The Dog API](https://thedogapi.com). The purpose was to create a production-ready backend that supports:

- Filtering dog breeds by lifespan
- Listing all breeds in alphabetical order
- Exporting breed data to PDF format

Everything was developed with enterprise-level structure in mind — modular, maintainable, and easily expandable. Below I explain **exactly** what was done, how it was structured, and why I made those decisions.

---

## 🔧 Environment & Tooling

### Why I picked this stack:

| Tool | Reason |
|------|--------|
| `FastAPI` | Lightweight, async-ready, comes with OpenAPI out-of-the-box. Ideal for clean, testable APIs. |
| `httpx` | Asynchronous HTTP client with better performance than requests. |
| `Pydantic` + `pydantic-settings` | Strong validation + env config loading. |
| `Poetry` | Clean dependency management, lock file support, production install isolation. |
| `Docker` | Containerization is essential for portability and CI/CD compatibility. |
| `Redis` (optional) | Included and working — not used yet, but ready for future caching or queuing. |
| `WeasyPrint` | Handles complex HTML-to-PDF conversion with CSS — better than reportlab for design. |

### Project structure is organized like this:

```bash
src/
├── api/          # All FastAPI route definitions
├── services/     # Business logic
├── repositories/ # Dog API calls and external integrations
├── models/       # Pydantic data schemas
├── config/       # App settings via .env
├── utils/        # Logging setup and PDF generation
└── main.py       # FastAPI app entry point
```

I built this structure because it clearly separates concerns. APIs don’t directly talk to external services — instead, they go through `services`, which in turn use `repositories`. This pattern makes the code easier to maintain and test as the system grows.

---

## 🚀 Functionality

### ✅ `/breeds/lifespan`
- **Method:** `GET`
- **Query:** `min_years`, `max_years`
- **What it does:** Filters breeds by lifespan range.
- **What I handled:** Lifespan values from Dog API are inconsistent — some are `"12 - 14 years"`, some `"10 years"`. I wrote a regex-based parser that extracts min/max and compares them safely. Invalid formats are skipped.

---

### ✅ `/breeds/alphabetical`
- **Method:** `GET`
- **What it does:** Returns a list of all breeds sorted by name.
- **Details:** I fetch the breeds, extract names, sort, and return them. Simple, clear logic.

---

### ✅ `/breeds/export/pdf`
- **Method:** `GET`
- **What it does:** Generates a downloadable PDF of all breed data, sorted alphabetically.
- **Implementation:** 
  - I used `Jinja2` to generate a clean HTML page with all breed info.
  - Then rendered it using `WeasyPrint` into a proper styled PDF.
  - This gives us the flexibility to change formatting later without touching code.

---

## 🔁 Reusability / Extensibility

Everything was built so we can scale it:

- ✅ Redis is up and running — ready for future caching.
- ✅ Easy to plug in pagination.
- ✅ Middleware for auth can be dropped in right away.
- ✅ PDF templates are editable in HTML/CSS.

---

## 🛠 Developer Experience

To make setup easy, I built two scripts:

### ✅ `startup.sh`
Runs the full project from scratch. It:

1. Creates a `.env` file with necessary vars.
2. Installs `poetry` (if missing).
3. Runs `poetry install` to pull in all dependencies.
4. Generates `poetry.lock` if it’s not there.
5. Brings down all Docker containers and volumes (in case something is stuck).
6. Builds and starts the whole app using Docker Compose.

This makes onboarding new devs (or impressing interviewers) a **1-line process**.

### ✅ `cleanup.sh`
Fully resets the project. It removes:
- Docker containers and volumes
- `.env`, compiled files, cache
- Any leftover artifacts like the exported PDF

Basically makes the repo fresh and ready to push to GitHub.

---

## 🧪 Testing

- Health check endpoint: tested.
- Lifespan: works with wide and narrow ranges.
- Alphabetical: clean sorted list.
- PDF export: confirmed content and formatting.
- Handled all edge cases like:
  - Missing lifespan data
  - Malformed input
  - Invalid API responses
  - PDF with empty list (returns styled empty doc)

---

## 📘 Documentation

- `README.md`: Fully updated and walkthrough added.
- `docs/`: Includes `endpoints.md` with all routes explained.
- MkDocs-ready.
- OpenAPI auto-generated by FastAPI at `/docs`.

---

## 🧠 Summary of Challenges

| Problem | How I solved it |
|--------|------------------|
| Dog API returning bad formats | Validated with type checks + fallback logging |
| Lifespan string parsing | Built a clean `parse_lifespan()` utility |
| API startup complexity | Built `startup.sh` to automate it all |
| PDF formatting from JSON | Jinja2 template + WeasyPrint = styled, real PDF |
| Structure getting messy | Separated `services`, `repositories`, `models` clearly |

---

## ✅ Final Check (From Job Requirements)

| Item | Done? |
|------|-------|
| Environment: Python, FastAPI, Poetry, Docker | ✅ |
| Filter by lifespan | ✅ |
| Alphabetical listing | ✅ |
| PDF export | ✅ |
| Fetch from Dog API, parse lifespan | ✅ |
| Setup scripts | ✅ |
| Documentation | ✅ |
| Error handling | ✅ |
| Enterprise-level structure | ✅ |
| GitHub-ready | ✅ |
